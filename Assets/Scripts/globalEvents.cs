using UnityEngine;
using System;
using System.Collections;

public class globalEvents : MonoBehaviour
{

	static public bool	CurrentMusicOnOffState = false;
	static public bool	CurrentSoundOnOffState = false;

	public class MusicOrSoundOnOffEventArgs : System.EventArgs
	{
		public MusicOrSoundOnOffEventArgs (bool onOrOff)
		{
			OnOrOff = onOrOff;
		}
		public bool OnOrOff { get; private set; }
	}

	public delegate void MusicOrSoundOnOffHandler (object sender,MusicOrSoundOnOffEventArgs e);

	// This event is for any component controlling music on/off
	static public event MusicOrSoundOnOffHandler MusicOnOff;

	// This should be called by any component controlling music on/off (i.e. the GUI)
	static public void OnMusicOnOff (object sender, bool onOrOff)
	{
		CurrentMusicOnOffState = onOrOff;
		if (MusicOnOff != null) {
			MusicOnOff (sender, new MusicOrSoundOnOffEventArgs (onOrOff));
		}
	}

	// This event is for any component controlling sound on/off
	static public event MusicOrSoundOnOffHandler SoundOnOff;

	// This should be called by any component controlling sound on/off (i.e. the GUI)
	static public void OnSoundOnOff (object sender, bool onOrOff)
	{
		CurrentSoundOnOffState = onOrOff;
		if (SoundOnOff != null) {
			SoundOnOff (sender, new MusicOrSoundOnOffEventArgs (onOrOff));
		}
	}

	public class GameObjectHitEventArgs : EventArgs
	{
		public GameObjectHitEventArgs(GameObject objHit)
		{
			objectHit = objHit;
		}

		public GameObject objectHit { get; set; }
	}
	public delegate void GameObjectHitEventHandler(object sender, GameObjectHitEventArgs e);

	// This event is triggered when any player character takes hit damage.
	static public event GameObjectHitEventHandler PlayerObjectHit;
	static public void OnPlayerObjectHit( object sender, GameObject playerObjectHit )
	{
		if (PlayerObjectHit != null)
		{
			PlayerObjectHit(sender, new GameObjectHitEventArgs(playerObjectHit) );
		}
	}

	// This event is triggered when any enemy character takes hit damage.
	static public event GameObjectHitEventHandler EnemyElementHit;
	static public void OnEnemyElementsHit( object sender, GameObject objectHit )
	{
		if (EnemyElementHit != null)
		{
			EnemyElementHit(sender, new GameObjectHitEventArgs(objectHit) );
		}
	}

	// This interfaces to a Service component which currently implements
	// object creation. This is used so that where the AI code requires a
	// character to be spawned (e.g. if a dead human turns into a zombie)
	// it can be done using this service. It decouples which components are
	// generated by the transformation from the AI.
	// NOTE: These methods are strictly for internal AI functionality, they 
	// don't affect mana at all. Use the mana controller functions to get
	// high level functions that also decrement from the mana.
	public interface ICharacterCreationService
	{
		GameObject createZombie(Vector3 referencePoint, Quaternion rotation);

		GameObject createFastZombie(Vector3 referencePoint, Quaternion rotation);

		werewolfAi createWerewolf(Vector3 referencePoint, Quaternion rotation);

		humanAI createHuman(Vector3 referencePoint, Quaternion rotation);

		guardAI createGuard(Vector3 referencePoint, Quaternion rotation);
	}

	// Use this to access the character creator service for this scene.
	// There has to be one of these objects otherwise the scene has not been
	// created correctly!!!!
	// Currently supported by "SceneControl" and "gameControl" objects so
	// have an object with one of these scripts in the scene a lot of AI
	// code will depend on it.
	static public ICharacterCreationService characterCreator { get; set; }

	// Interface that identifies a mana-controller
	public interface IManaController
	{
		void ChangeMana(float manaDelta);

		bool CanIBuyAZombie();

		GameObject RequestBuyZombie(Vector3 position, Quaternion rotation);
	}

	static public IManaController manaControllerService { get; set; }

	// Legacy behavior : Older scenes don't move zombies on their own.
	static public bool shouldZombiesMoveOnTheirOwn = false;
}
